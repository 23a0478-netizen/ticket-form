import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp, integer, pgEnum, primaryKey } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { relations } from "drizzle-orm";

// Enum for application status
export const applicationStatusEnum = pgEnum("application_status", [
  "pending",
  "approved",
  "rejected",
]);

// Events table
export const events = pgTable("events", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  description: text("description").notNull(),
  applicationDeadline: timestamp("application_deadline").notNull(),
  liveDate: timestamp("live_date").notNull(),
  maxPeoplePerApplication: integer("max_people_per_application").notNull().default(10),
  createdAt: timestamp("created_at").notNull().default(sql`now()`),
});

export const eventsRelations = relations(events, ({ many }) => ({
  ticketTypes: many(ticketTypes),
  applications: many(applications),
}));

// Ticket types table
export const ticketTypes = pgTable("ticket_types", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  eventId: varchar("event_id")
    .notNull()
    .references(() => events.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  description: text("description").notNull(),
  notes: text("notes"),
});

export const ticketTypesRelations = relations(ticketTypes, ({ one, many }) => ({
  event: one(events, {
    fields: [ticketTypes.eventId],
    references: [events.id],
  }),
  applicationTickets: many(applicationTickets),
}));

// Applications table
export const applications = pgTable("applications", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  eventId: varchar("event_id")
    .notNull()
    .references(() => events.id, { onDelete: "cascade" }),
  representativeName: text("representative_name").notNull(),
  numberOfPeople: integer("number_of_people").notNull(),
  deviceFingerprint: text("device_fingerprint").notNull(),
  status: applicationStatusEnum("status").notNull().default("pending"),
  appliedAt: timestamp("applied_at").notNull().default(sql`now()`),
  updatedAt: timestamp("updated_at").notNull().default(sql`now()`),
});

export const applicationsRelations = relations(applications, ({ one, many }) => ({
  event: one(events, {
    fields: [applications.eventId],
    references: [events.id],
  }),
  applicationTickets: many(applicationTickets),
}));

// Application tickets junction table (many-to-many)
export const applicationTickets = pgTable(
  "application_tickets",
  {
    applicationId: varchar("application_id")
      .notNull()
      .references(() => applications.id, { onDelete: "cascade" }),
    ticketTypeId: varchar("ticket_type_id")
      .notNull()
      .references(() => ticketTypes.id, { onDelete: "cascade" }),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.applicationId, table.ticketTypeId] }),
  })
);

export const applicationTicketsRelations = relations(applicationTickets, ({ one }) => ({
  application: one(applications, {
    fields: [applicationTickets.applicationId],
    references: [applications.id],
  }),
  ticketType: one(ticketTypes, {
    fields: [applicationTickets.ticketTypeId],
    references: [ticketTypes.id],
  }),
}));

// Insert schemas
export const insertEventSchema = createInsertSchema(events).omit({
  id: true,
  createdAt: true,
});

export const insertTicketTypeSchema = createInsertSchema(ticketTypes).omit({
  id: true,
});

export const insertApplicationSchema = createInsertSchema(applications).omit({
  id: true,
  appliedAt: true,
  updatedAt: true,
  status: true,
});

// Type exports
export type Event = typeof events.$inferSelect;
export type InsertEvent = z.infer<typeof insertEventSchema>;

export type TicketType = typeof ticketTypes.$inferSelect;
export type InsertTicketType = z.infer<typeof insertTicketTypeSchema>;

export type Application = typeof applications.$inferSelect;
export type InsertApplication = z.infer<typeof insertApplicationSchema>;

export type ApplicationTicket = typeof applicationTickets.$inferSelect;

// Extended types with relations
export type ApplicationWithTickets = Application & {
  tickets: TicketType[];
};

export type EventWithTickets = Event & {
  ticketTypes: TicketType[];
};
